<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.82.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Jeff&#39;s Blog</title><link rel="stylesheet" href="/css/core.min.4bcb6f9f298d758a08f497bd63bbb01d412ec22761b87bd901a8165397f9b9f96b165b7e399ffed8eb58801109781944.css" integrity="sha384-S8tvnymNdYoI9Je9Y7uwHUEuwidhuHvZAagWU5f5uflrFlt&#43;OZ/&#43;2OtYgBEJeBlE"><link rel="alternate" type="application/rss+xml" href="/index.xml" title="Jeff's Blog" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Jeff&#39;s Blog" /><link rel="icon" type="image/ico" sizes="128x128" href="/favicon.ico"><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/Sheldon1.jpeg" alt /><span class="site name">Jeff's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="https://github%2ecom/jeff2857"target="_blank" rel="noopener noreferrer">Github</a></nav></div></span></div></section><section id="content"><ul class="note list"><li class="item"><a class="note" href="/posts/leetcode/binary-search-tree/">
            <p class="note title">二叉查找树</p><p class="note date">2021-09-02</p><p class="note content">在一组排好序的数中查找某个值是否在，有一种常用的方法叫做二分查找。二分查找的思想是，先判断这组数中间位置的那个元素是否和目标值相等，如果相等，则这个元素就是要查找的元素；否则，将数组从中间位置分成两半，假设数组是升序的，那么左半部分小于（等<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/leetcode/">LeetCode</a></p></li><li class="item"><a class="note" href="/posts/java/basic/copy/">
            <p class="note title">Java 中的对象拷贝</p><p class="note date">2021-06-04</p><p class="note content">有时候我们需要创建一个对象的复制品，这个复制品和原来的对象拥有相同的类型、相同的属性。这个过程就是对象的拷贝。 Java 中有三种类型的拷贝：浅拷贝(Shallow Copy)，深拷贝(Deep Copy)，延迟拷贝(Lazy Copy)。 浅拷贝 浅拷贝在复<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/java/">Java</a></p></li><li class="item"><a class="note" href="/posts/java/basic/object/">
            <p class="note title">Java Object Class</p><p class="note date">2021-05-25</p><p class="note content">Object 是所有类的基类，他有一些方法是我们经常用到的，比如 equals(Object obj), hashCode(), 还有并发编程中用到的 notify(), wait() 等。 定义一个类时，如果没有用 extends 去继承其他类，那么他会隐式地继承 Object 类，我们也可以显式地去继承 Object 类，这两种方式是一样的。 // 隐式 class MyClass {} // 显式 class MyClass extends Object {} Object 类中有一些方<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/java/">Java</a></p></li><li class="item"><a class="note" href="/posts/java/basic/generics/">
            <p class="note title">Java Generics</p><p class="note date">2021-05-25</p><p class="note content">泛型的概念 泛型，也就是把类型参数化。比如定义一个方法，他需要对几种不同的数据类型做相同的处理，如果不用泛型，那我们就需要定义好几个方法，每个方法对应每种数据类型。这几个方法只是参数类型不同，方法体都是一样的，那么就显得很冗余。 拿比较常用的 List<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/java/">Java</a></p></li><li class="item"><a class="note" href="/posts/vim/golang-ide/">
            <p class="note title">vim 配置 Golang 开发</p><p class="note date">2021-05-23</p><p class="note content">我很喜欢 Vim 编辑器，也想学习下 Golang，于是在一台旧的 Macbook Pro 上配置了 Golang 的 Vim 开发环境。 neovim 和 vim-plug 我使用的是 neovim，插件管理用的是 vim-plug。首先通过 homebrew 安装 neovim: brew install neovim 安装完成后，通过命令 nvim 启动 neovim，我在 zsh 的配置文件 .zshrc 里添加了 alias vim=&#34;nvim&#34; 这<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/vim/">Vim</a></p></li><li class="item"><a class="note" href="/posts/java/jvm/class_file/">
            <p class="note title">Java Class 文件</p><p class="note date">2021-04-27</p><p class="note content">(未完待续) 简介 class 文件是二进制格式的，它包含了被 JVM 执行的代码。由于 class 文件是由 JVM 来执行的，所以它不依赖特定硬件和操作系统。class 文件格式中定义了类与接口的表示形式，包括平台相关的一些细节（如字节序，A平台为大端序存储，B平台为小端序存储）<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/jvm/">JVM</a></p></li><li class="item"><a class="note" href="/posts/computer-science/sicp/scheme-env/">
            <p class="note title">Scheme 环境搭建</p><p class="note date">2021-04-22</p><p class="note content">MIT-Scheme 在 Mac 上，使用 homebrew 安装 brew install Caskroom/cask/xquartz brew install mit-scheme 然后执行 Scheme 命令进入 Scheme 解释器 Emacs 另一种方式是安装 emacs，它自带 lisp 解释器 brew cask install emacs 不过 emacs 的使用也需要学习一下，输入命令 emacs 打开它，然后可以直接输入程序，如 (+ 1 2) 将光标移至该行末尾，按下 Ctrl-x Ctrl-e 即可执行改行代码，执行结果<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/sicp/">SICP</a></p></li><li class="item"><a class="note" href="/posts/terminal/ssh-shortcut/">
            <p class="note title">配置SSH快捷连接</p><p class="note date">2021-04-09</p><p class="note content">在 ~/.ssh 目录下有个 config 文件，修改该文件添加主机配置： Host * ServerAliveInterval 60 Host 47 HostName 47.114.62.251 User root Port 22 IdentityFile ~/.ssh/id_rsa 即可通过命令 ssh 47 连接至服务器</p></a><p class="note labels"><a class="category" href="/categories/terminal/">Terminal</a></p></li><li class="item"><a class="note" href="/posts/vim/buffer-window-tab/">
            <p class="note title">Buffers, Windows, Tabs in Vim</p><p class="note date">2021-02-14</p><p class="note content">Most editors, like VSCode, use tabs and windows system. A tab usually means an opened file, and when we close it, the file goes away.
Vim use buffers, windows and tabs, and they are different from most editors.
Buffer First, let&rsquo;s look at buffers in vim.
A buffer is the in-memory text of a file.
When we open a file in vim, it creates a buffer in memory. And what in this buffer is the file&rsquo;s content. When we edit the file, we edit the buffer.
Let&rsquo;s try to edit a file named file1:
vim file1 Vim creates a new buffer for file1 in memory. When we type :q to quit vim, the buffer will be cleared and there will be no file file1 stored on disk because we didn&rsquo;t write anything to the buffer.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/vim/">Vim</a></p></li><li class="item"><a class="note" href="/posts/leetcode/word-break-139/">
            <p class="note title">LeetCode - 139.单词拆分</p><p class="note date">2020-11-04</p><p class="note content">题目 来源：139.单词拆分 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明 拆分时可以重复使用字典中的单词 你可以假设字典中没有重复的单词 示例1 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 输出:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/leetcode/">LeetCode</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/">1</a></li><li><a class="" href="/page/2/">2</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Jeff's Blog</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><script src="/js/hljs.min.72e76ccf211868d08e31d7ca45c02501991bd760f28809c52045fa79fb7b7428664bb54ae875b46031ebc760c77b9562.js" integrity="sha384-cudszyEYaNCOMdfKRcAlAZkb12DyiAnFIEX6eft7dChmS7VK6HW0YDHrx2DHe5Vi"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>