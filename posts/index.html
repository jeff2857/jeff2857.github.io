<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.82.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Posts&nbsp;&ndash;&nbsp;Jeff&#39;s Blog</title><link rel="stylesheet" href="/css/core.min.4bcb6f9f298d758a08f497bd63bbb01d412ec22761b87bd901a8165397f9b9f96b165b7e399ffed8eb58801109781944.css" integrity="sha384-S8tvnymNdYoI9Je9Y7uwHUEuwidhuHvZAagWU5f5uflrFlt&#43;OZ/&#43;2OtYgBEJeBlE"><link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="Jeff's Blog" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Posts" /><link rel="icon" type="image/ico" sizes="128x128" href="/favicon.ico"><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/Sheldon1.jpeg" alt /><span class="site name">Jeff's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="https://github%2ecom/jeff2857"target="_blank" rel="noopener noreferrer">Github</a></nav></div></span></div></section><section id="content"><section class="article header"><h1>Posts</h1></section><ul class="note list"><li class="item"><a class="note" href="/posts/java/basic/generics/">
            <p class="note title">Java Generics</p><p class="note date">2021-05-25</p><p class="note content">泛型的概念 泛型，也就是把类型参数化。比如定义一个方法，他需要对几种不同的数据类型做相同的处理，如果不用泛型，那我们就需要定义好几个方法，每个方法对应每种数据类型。这几个方法只是参数类型不同，方法体都是一样的，那么就显得很冗余。 拿比较常用的 List<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/posts/vim/golang-ide/">
            <p class="note title">vim 配置 Golang 开发</p><p class="note date">2021-05-23</p><p class="note content">我很喜欢 Vim 编辑器，也想学习下 Golang，于是在一台旧的 Macbook Pro 上配置了 Golang 的 Vim 开发环境。 neovim 和 vim-plug 我使用的是 neovim，插件管理用的是 vim-plug。首先通过 homebrew 安装 neovim: brew install neovim 安装完成后，通过命令 nvim 启动 neovim，我在 zsh 的配置文件 .zshrc 里添加了 alias vim=&#34;nvim&#34; 这<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/posts/java/jvm/class_file/">
            <p class="note title">Java Class 文件</p><p class="note date">2021-04-27</p><p class="note content">(未完待续) 简介 class 文件是二进制格式的，它包含了被 JVM 执行的代码。由于 class 文件是由 JVM 来执行的，所以它不依赖特定硬件和操作系统。class 文件格式中定义了类与接口的表示形式，包括平台相关的一些细节（如字节序，A平台为大端序存储，B平台为小端序存储）<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/jvm/">JVM</a></p></li><li class="item"><a class="note" href="/posts/computer-science/sicp/scheme-env/">
            <p class="note title">Scheme 环境搭建</p><p class="note date">2021-04-22</p><p class="note content">MIT-Scheme 在 Mac 上，使用 homebrew 安装 brew install Caskroom/cask/xquartz brew install mit-scheme 然后执行 Scheme 命令进入 Scheme 解释器 Emacs 另一种方式是安装 emacs，它自带 lisp 解释器 brew cask install emacs 不过 emacs 的使用也需要学习一下，输入命令 emacs 打开它，然后可以直接输入程序，如 (+ 1 2) 将光标移至该行末尾，按下 Ctrl-x Ctrl-e 即可执行改行代码，执行结果<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/sicp/">SICP</a></p></li><li class="item"><a class="note" href="/posts/terminal/ssh-shortcut/">
            <p class="note title">配置SSH快捷连接</p><p class="note date">2021-04-09</p><p class="note content">在 ~/.ssh 目录下有个 config 文件，修改该文件添加主机配置： Host * ServerAliveInterval 60 Host 47 HostName 47.114.62.251 User root Port 22 IdentityFile ~/.ssh/id_rsa 即可通过命令 ssh 47 连接至服务器</p></a><p class="note labels"><a class="category" href="/categories/terminal/">Terminal</a></p></li><li class="item"><a class="note" href="/posts/vim/buffer-window-tab/">
            <p class="note title">Buffers, Windows, Tabs in Vim</p><p class="note date">2021-02-14</p><p class="note content">Most editors, like VSCode, use tabs and windows system. A tab usually means an opened file, and when we close it, the file goes away.
Vim use buffers, windows and tabs, and they are different from most editors.
Buffer First, let&rsquo;s look at buffers in vim.
A buffer is the in-memory text of a file.
When we open a file in vim, it creates a buffer in memory. And what in this buffer is the file&rsquo;s content. When we edit the file, we edit the buffer.
Let&rsquo;s try to edit a file named file1:
vim file1 Vim creates a new buffer for file1 in memory. When we type :q to quit vim, the buffer will be cleared and there will be no file file1 stored on disk because we didn&rsquo;t write anything to the buffer.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/vim/">Vim</a></p></li><li class="item"><a class="note" href="/posts/leetcode/word-break-139/">
            <p class="note title">LeetCode - 139.单词拆分</p><p class="note date">2020-11-04</p><p class="note content">题目 来源：139.单词拆分 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明 拆分时可以重复使用字典中的单词 你可以假设字典中没有重复的单词 示例1 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 输出:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/leetcode/">LeetCode</a></p></li><li class="item"><a class="note" href="/posts/java/spring/cron/">
            <p class="note title">@Scheduled(cron = "") 表达式</p><p class="note date">2020-09-27</p><p class="note content">常用 cron 表达式 每隔5秒执行一次：*/5 * * * * ? 每隔10分钟执行一次：0 */10 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/spring/">Spring</a></p></li><li class="item"><a class="note" href="/posts/leetcode/majority-element/">
            <p class="note title">摩尔投票算法</p><p class="note date">2020-09-27</p><p class="note content">leetcode 169. 多数元素(majority element) 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例1 输入: [3,2,3] 输出: 3 示例2 输入: [2,2,1,1,1,2,2] 输出: 2 一些常用解法： 遍历<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/leetcode/">LeetCode</a></p></li><li class="item"><a class="note" href="/posts/leetcode/sort-algorithms/">
            <p class="note title">常见排序算法总结</p><p class="note date">2020-05-19</p><p class="note content">(未完待续) 冒泡排序 冒泡排序比较简单，以从小到大排序为例，从索引为0的位置向后遍历数组，每次遍历比较当前元素和下一个元素的值，若当前元素值较大，则交换两个元素，继续向后遍历，这样一轮遍历下来，最后一个元素为该数组中的最大值；继续从索引为0的<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/leetcode/">LeetCode</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/posts/">1</a></li><li><a class="" href="/posts/page/2/">2</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Jeff's Blog</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><script src="/js/hljs.min.72e76ccf211868d08e31d7ca45c02501991bd760f28809c52045fa79fb7b7428664bb54ae875b46031ebc760c77b9562.js" integrity="sha384-cudszyEYaNCOMdfKRcAlAZkb12DyiAnFIEX6eft7dChmS7VK6HW0YDHrx2DHe5Vi"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>