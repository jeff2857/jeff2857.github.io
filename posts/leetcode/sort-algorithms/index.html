<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.82.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>常见排序算法总结&nbsp;&ndash;&nbsp;Jeff&#39;s Blog</title><link rel="stylesheet" href="/css/core.min.4bcb6f9f298d758a08f497bd63bbb01d412ec22761b87bd901a8165397f9b9f96b165b7e399ffed8eb58801109781944.css" integrity="sha384-S8tvnymNdYoI9Je9Y7uwHUEuwidhuHvZAagWU5f5uflrFlt&#43;OZ/&#43;2OtYgBEJeBlE"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="常见排序算法总结" /><link rel="icon" type="image/ico" sizes="128x128" href="/favicon.ico"><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/Sheldon1.jpeg" alt /><span class="site name">Jeff's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="https://github%2ecom/jeff2857"target="_blank" rel="noopener noreferrer">Github</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">常见排序算法总结</h1><p class="article date">2020-05-19</p></section><article class="article markdown-body"><p>在我们的编程工作中，经常会对一组数据做<strong>排序</strong>操作，排序的算法也有很多。这里总结了几个常见的排序算法，以下默认都是升序。</p>
<h2 id="冒泡排序">冒泡排序</h2>
<p>考虑一组数 <code>[3, 2, 5, 1, 4]</code>，我们想让他以升序的方式排序，那么最大的数 <code>5</code> 是要排在最后一个位置，<code>4</code> 排在倒数第二个位置，以此类推。</p>
<p>那怎么样才能把 <code>5</code> 放在最后一个位置呢？我们可以遍历数组，找到其中最大的数，并且记录他的位置（索引），然后把这个数与最后一个数交换位置即可；还有一种方法，就是从数组第一个元素开始，比较他与他后面的那个数，把这两个数中较大的数移到后面，接着到第二个元素，重复这个步骤，这样一轮遍历下来，最大的数就被移到了最后一个位置。</p>
<p>不论用哪一种方法，一轮遍历后，数组末尾位置的元素就是最大值，这个元素也相当于已经被排好了序。那么我们只需要对其余元素构成的数组，也就是 <code>[2, 3, 1, 4]</code> 这个数组排序，重复上述方法即可。</p>
<p>上述两种方法中，后者不需要记录每一轮遍历中最大数及其位置，由于这个<strong>比较相邻元素并把较大值后移</strong>的操作就好像把一个泡泡从数组第一个位置不断后移，泡泡里的元素是每次比较的较大值，所以这种排序算法被称为<strong>冒泡排序</strong>。</p>
<p>可以看出，冒泡排序算法使用了两层遍历，时间复杂度是 <code>O(n^2)</code>。用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 外层循环为遍历的轮数
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 内层循环为每一轮对数组的遍历
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ary</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// 比较当前元素和下一个元素的值
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span> <span class="c1">// 若当前值较大，则交换两个元素
</span><span class="c1"></span>                <span class="n">ary</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="选择排序">选择排序</h2>
<p>在上文讲冒泡排序每一轮的遍历时，讲到了找出最大值并把他放到合适的位置上的方法，这其实就是<strong>选择排序</strong>的思想。</p>
<p>我们在每一轮遍历数组时，找到最大值及其索引，然后交换他和末尾元素的位置，然后对除去这个元素后剩余元素构成的数组重复这个步骤即可。</p>
<p>当然，也可以改为找到每一轮中的最小值并把他放在合适的位置上，就是记录每次遍历开始位置的索引 i，同时用变量 lowIndex 标记每轮循环中值最小的元素索引，在每轮循环结束后，交换位置 i 和位置 lowIndex 的元素，第一轮结束后，位置 i 处为数组最小值；将 i + 1，第二轮遍历遍历结束并交换相应元素位置后，数组第二个位置为第二小元素；重复上述步骤，直到所有元素都排好序.</p>
<p>选择排序的时间复杂度也是 <code>O(n^2)</code>，用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">selectSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">lowIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// 初始化 lowIndex 为数组未排序部分的第一个元素
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 找到未排序部分值最小的元素索引
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">ary</span><span class="o">[</span><span class="n">lowIndex</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">lowIndex</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 交换位置 i 和位置 lowIndex 的元素
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">ary</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">lowIndex</span><span class="o">];</span>
        <span class="n">ary</span><span class="o">[</span><span class="n">lowIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="归并排序">归并排序</h2>
<p><strong>归并排序</strong>是<strong>分治法</strong>思想的体现，对于一个大数组我们不好排序，但是对于两个数排序是很方便的，所以何不将这个大数组分成两个小数组，再把每个小数组继续分，直到最终的一个小数组被分为两个只包含一个元素的数组为止。我们对这两个数比较大小，并把这两个长度为 1 的数组合并为一个长度为 2 的数组，合并后的数组就是排好序的。重复这个步骤，把两个长度为 2 的数组合并为一个长度为 4 的已排序数组，两个长度为 4 的数组合并为一个长度为 8 的数组…… 直到最终合并为一个长度和原数组相同的大数组，这个数组就是排好序的。</p>
<p>下面是一个示意图，绿色线上方是分割，下方是合并：</p>
<p><span class="image-container"><span class="link"><img class="img" src="merge-sort.png"
        alt="merge-sort"/></span></span></p>
<p>归并排序的时间复杂度是 <code>O(nlogn)</code>，用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="n">1</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">];</span> <span class="c1">// 左半部分数组
</span><span class="c1"></span>	<span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">);</span>

	<span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">);</span> <span class="c1">// 递归调用排序
</span><span class="c1"></span>
	<span class="kt">int</span> <span class="n">rightLen</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLen</span><span class="o">];</span> <span class="c1">// 右半部分数组
</span><span class="c1"></span>	<span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">rightLen</span><span class="o">);</span>

	<span class="n">mergeSort</span><span class="o">(</span><span class="n">right</span><span class="o">);</span> <span class="c1">// 递归调用排序
</span><span class="c1"></span>
	<span class="n">merge</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">ary</span><span class="o">);</span> <span class="c1">// 合并左右两个数组
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">indexLeft</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// 左数组索引
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">indexRight</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// 右数组索引
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">indexTemp</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// 合并后的数组索引
</span><span class="c1"></span>
	<span class="c1">// 按升序合并两个数组
</span><span class="c1"></span>	<span class="k">while</span> <span class="o">(</span><span class="n">indexLeft</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">indexRight</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">indexLeft</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">[</span><span class="n">indexRight</span><span class="o">])</span> <span class="o">{</span>
			<span class="n">temp</span><span class="o">[</span><span class="n">indexTemp</span><span class="o">++]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">indexLeft</span><span class="o">++];</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">temp</span><span class="o">[</span><span class="n">indexTemp</span><span class="o">++]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">indexRight</span><span class="o">++];</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">indexLeft</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span><span class="o">[</span><span class="n">indexTemp</span><span class="o">++]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">indexLeft</span><span class="o">++];</span>
	<span class="o">}</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">indexRight</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span><span class="o">[</span><span class="n">indexTemp</span><span class="o">++]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">indexRight</span><span class="o">++];</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="快速排序">快速排序</h2>
<p><strong>快速排序</strong>的思想是，从数组中选出一个元素，这个元素也被成为<strong>主元</strong>(pivot)，根据这个主元，把数组分为两部分。第一部分中所有的元素都小于等于主元，第二部分中所有的元素都大于主元。这样从宏观来看，第一部分数组、主元、第二部分数组这三者相当于已经排好序。接着对第一部分和第二部分数组递归调用该排序算法即可。</p>
<p>至于主元的选择，一般选择数组的第一个元素。主元的选择也会影响算法的效率。</p>
<p>快速排序的时间复杂度为 <code>O(nlogn)</code>，用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">quickSort</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
		<span class="n">quickSort</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// 递归左半部分数组
</span><span class="c1"></span>		<span class="n">quickSort</span><span class="o">(</span><span class="n">ary</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span> <span class="c1">// 递归右半部分数组
</span><span class="c1"></span>	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 分割数组 ary[left:right] 部分
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">left</span><span class="o">];</span> <span class="c1">// 选取数组第一个元素作为主元
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">high</span><span class="o">--;</span>
		<span class="o">}</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">ary</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">low</span><span class="o">++;</span>
		<span class="o">}</span>

		<span class="c1">// 交换两个数，把大数放右边，小数放左边
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">high</span> <span class="o">&gt;</span> <span class="n">low</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
			<span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
			<span class="n">ary</span><span class="o">[</span><span class="n">low</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">high</span> <span class="o">&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">high</span><span class="o">--;</span>
	<span class="o">}</span>

	<span class="k">if</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">&gt;</span> <span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">])</span> <span class="o">{</span>
		<span class="n">ary</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
		<span class="n">ary</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">high</span><span class="o">;</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">left</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="插入排序">插入排序</h2>
<p>首先将数组的第一个元素作为已排好序的元素，从第二个元素向后遍历，若第二个元素比第一个元素的值大，则将第二个元素插入第一个元素前，否则将他插入第一个元素后；接着拿下一个元素依次与它之前已排好序的元素比较，直到插入到合适的位置；重复这一步骤，直到所有元素都排好序。</p>
<p>插入排序时间复杂度为 <code>O(n^2)</code>，用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 第一个元素作为已排好序的元素，所以从第二个元素开始遍历
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// 当前元素
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="c1">// 拿当前元素与它前面的元素依次比较，不满足条件则将元素后移，否则插入元素
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">--];</span> <span class="c1">// 后移元素
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> <span class="c1">// 插入当前元素
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="希尔排序">希尔排序</h2>
<p>对于插入排序，如果数组中大部分元素都是有序的，那么每次比较的次数将会大大减少，这样就能提高算法的效率。</p>
<p>那么怎样才能让数组中的大部分元素有序呢？有个计算机科学家发明了一种方法，这种方法以他的名字命名，称为<strong>希尔排序</strong>。</p>
<p>首先，我们让数组中的元素两两一组，每组中的两个元素跨度为数组长度的一半，以数组 <code>[6, 2, 5, 8, 4, 1, 7, 3]</code> 为例，分组后为 <code>[6, 4], [2, 1], [5, 7], [8, 3]</code> 这四个数组，跨度为 4。</p>
<p>对每个小数组做插入排序，排序后原数组已变为 <code>[4, 1, 5, 3, 6, 2, 7, 8]</code>，可以看到，数组的整体有序程度有了一定提高。如果后续使用插入排序算法进行排序，会比直接对原数组做插入排序效率要高不少。</p>
<p>我们继续对数组分组，不过要把跨度调整为之前的一半，也就是 2。这样就分组成了 <code>[4, 5, 6, 7], [1, 3, 2, 8]</code>，对每个小数组做插入排序，排序后原数组变为 <code>[4, 1, 5, 2, 6, 3, 7, 8]</code>。接着再把跨度调整为一半，也就是 1，再做插入排序，这其实等同于直接做插入排序，最终就是排好序的数组。</p>
<p>其实希尔排序就是为了减少插入排序的工作量，平均时间复杂度比 <code>O(n^2)</code> 要小，用 <code>Java</code> 代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shellSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
	<span class="c1">// 取跨度为数组长度的一半，每次减半
</span><span class="c1"></span>	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">gap</span> <span class="o">/</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
			<span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">gap</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="o">];</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">ary</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="o">];</span>
			<span class="o">}</span>
			<span class="n">ary</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="堆排序">堆排序</h2>
<p>二叉树我们都比较熟悉，其中有这样一种二叉树，他满足以下属性：</p>
<ul>
<li>是完全二叉树</li>
<li>每个节点大于等于（或小于等于）他的任意一个孩子</li>
</ul>
<p>这样的一棵二叉树被称为<strong>二叉堆</strong>，如果他的每个节点大于等于他的任意一个孩子，那么这个二叉堆称为<strong>最大堆</strong>，反之称为<strong>最小堆</strong>。</p>
<p>很明显，二叉堆中的节点是排好序的。对于一组无序的数，如果我们把他构造成一个二叉堆，那么也就实现了对他的排序。下面我们来看如何构造一个二叉堆（因为是升序，我们的二叉堆是最小堆）。</p>
<p>我们可以用一个 <code>ArrayList</code> 来存储这个堆，根节点索引为 0，他的左子节点索引为 1，右子节点索引为 2。可以推断出，对于一个索引在 <code>i</code> 处的节点，他的左子节点索引为 <code>2i + 1</code>，右子节点索引为 <code>2i + 2</code>，父节点索引为 <code>(i-1)/2</code>。对于下面这个二叉堆，就可以存储为 <code>[1, 2, 3, 9, 5, 6, 7]</code>：</p>
<p><span class="image-container"><span class="link"><img class="img" src="binary-heap.png"
        alt="binary-heap"/></span></span></p>
<p>我们先构造一个二叉堆的大体结构，然后实现他相应的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryHeap</span> <span class="o">{</span>
	<span class="c1">// 用一个 ArrayList 来存储二叉堆中的节点
</span><span class="c1"></span>	<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

	<span class="kd">public</span> <span class="nf">BinaryHeap</span><span class="o">()</span> <span class="o">{}</span>

	<span class="c1">// 把一个整型数组构造为一个二叉堆
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">BinaryHeap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="c1">// 向堆中添加节点
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>

	<span class="o">}</span>

	<span class="c1">// 删除节点
</span><span class="c1"></span>	<span class="kd">public</span> <span class="n">Integer</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>向二叉堆中添加节点时，我们先把这个节点添加到堆的末尾，然后按照如下方式对树中的节点排序，使得他满足二叉堆的属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 把新的节点添加到堆的末尾
</span><span class="c1"></span>	<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>

	<span class="c1">// 新增节点的索引
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">curIndex</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">curIndex</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 当前节点的父节点的索引
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">parentIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">curIndex</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
		<span class="c1">// 如果当前节点的值比他的父节点小，则交换两个节点
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curIndex</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parentIndex</span><span class="o">))</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curIndex</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">curIndex</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parentIndex</span><span class="o">));</span>
			<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">parentIndex</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="c1">// 如果当前节点的值大于等于他的父节点，则这棵树已经满足二叉堆的条件
</span><span class="c1"></span>			<span class="k">break</span><span class="o">;</span>
		<span class="o">}</span>

    	<span class="n">curIndex</span> <span class="o">=</span> <span class="n">parentIndex</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>二叉堆的删除操作一般是删除其中最小（或最大，根据他是最小堆或最大堆）的值，也就是根节点。删除根节点后我们需要对这棵树中的节点重排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Integer</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

	<span class="c1">// 删除根节点
</span><span class="c1"></span>	<span class="c1">// 先把堆的末尾节点和根节点交换，然后删除末尾节点
</span><span class="c1"></span>	<span class="c1">// 现在要删除的节点在末尾，删除即可
</span><span class="c1"></span>	<span class="c1">// 原来末尾节点的值已被移至根节点的位置，需要重排序
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">removedElem</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
	<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">));</span>
	<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>

	<span class="kt">int</span> <span class="n">curIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">curIndex</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
		<span class="c1">// 左子节点的索引
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">leftChildIndex</span> <span class="o">=</span> <span class="n">2</span> <span class="o">*</span> <span class="n">curIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
		<span class="c1">// 右子节点的索引
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">rightChildIndex</span> <span class="o">=</span> <span class="n">2</span> <span class="o">*</span> <span class="n">curIndex</span> <span class="o">+</span> <span class="n">2</span><span class="o">;</span>

		<span class="c1">// 已到达末尾节点
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">leftChildIndex</span> <span class="o">&gt;=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="k">break</span><span class="o">;</span>

		<span class="c1">// 取当前最大值为左子节点的值
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">maxIndex</span> <span class="o">=</span> <span class="n">leftChildIndex</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">rightChildIndex</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
			<span class="c1">// 取左右子节点中较小的值作为当前的最小值
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxIndex</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rightChildIndex</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">maxIndex</span> <span class="o">=</span> <span class="n">rightChildIndex</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="c1">// 如果当前节点的值比他左右子节点中的最小值要大，
</span><span class="c1"></span>		<span class="c1">// 则交换这两个节点
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curIndex</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxIndex</span><span class="o">))</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxIndex</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">maxIndex</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curIndex</span><span class="o">));</span>
			<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">curIndex</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
			<span class="n">curIndex</span> <span class="o">=</span> <span class="n">maxIndex</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="c1">// 当前节点的值比他左右子节点中最小值还要小或与之相等，
</span><span class="c1"></span>			<span class="c1">// 说明当前节点已满足最小堆的条件
</span><span class="c1"></span>			<span class="k">break</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">removedElem</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>至此，一个二叉堆的实现已完成，接下来用这个二叉堆来实现我们的堆排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">heapSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">BinaryHeap</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryHeap</span><span class="o">();</span>

	<span class="c1">// 将当前数组构造为一个二叉堆
</span><span class="c1"></span>	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">// 删除二叉堆中的最小值，并赋值给原数组
</span><span class="c1"></span>	<span class="c1">// 则原数组按升序排序
</span><span class="c1"></span>	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">ary</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>堆排序的时间复杂度为 <code>O(nlogn)</code>。</p>
<h2 id="桶排序">桶排序</h2>
<p>对于一个整型数组，如果其中元素的值范围为 <code>[0, t]</code>，我们就用 <code>t+1</code> 个标记为 <code>0, 1, ..., t</code> 的桶。对数组中的每个元素，如果元素的值为 <code>i</code>，就把他放入桶 <code>i</code> 中。这样，每个桶 <code>i</code> 中，都存放着值为 <code>i</code> 的相同元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">bucketSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 创建一个桶，桶的每个元素是一个 ArrayList，t 是数组中的最大值
</span><span class="c1"></span>	<span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;[]</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">[</span><span class="n">t</span><span class="o">+</span><span class="n">1</span><span class="o">];</span>
	
	<span class="c1">// 把值为 i 的元素放入桶 i 中
</span><span class="c1"></span>	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">ary</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">bucket</span><span class="o">[</span><span class="n">elem</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">bucket</span><span class="o">[</span><span class="n">elem</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;();</span>
		<span class="o">}</span>
		<span class="n">bucket</span><span class="o">[</span><span class="n">elem</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">// 遍历桶及桶的每个元素，
</span><span class="c1"></span>	<span class="c1">// 由于是按索引从小到大遍历
</span><span class="c1"></span>	<span class="c1">// 最终的数组未升序排序
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">ary</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">elem</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>桶排序的时间复杂度为 <code>O(n+t)</code>，其中 <code>n</code> 是数组大小，<code>t</code> 是数组中的最大值。</p>
</article><section class="article labels"><a class="category" href=/categories/leetcode/>LeetCode</a></section><section class="article author"><p class="name">Jeff Liu</p><div class="details"><a class="item" href="mailto:jeffliu2857@gmail.com" target="_blank" rel="noopener noreferrer"><span class="iconfont icon-email"></span>&nbsp;jeffliu2857@gmail.com</a></div>
</section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/leetcode/majority-element/"><span class="iconfont icon-article"></span>摩尔投票算法</a></p><p><a class="link" href="/posts/docker/install-docker-on-centos8/"><span class="iconfont icon-article"></span>Centos8 安装 Docker 过程及错误解决</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Jeff's Blog</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><script src="/js/hljs.min.72e76ccf211868d08e31d7ca45c02501991bd760f28809c52045fa79fb7b7428664bb54ae875b46031ebc760c77b9562.js" integrity="sha384-cudszyEYaNCOMdfKRcAlAZkb12DyiAnFIEX6eft7dChmS7VK6HW0YDHrx2DHe5Vi"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>